// Package main provides an example plugin for go-pre-commit that checks license headers.
package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Define plugin errors
var (
	ErrLicenseFileNotFound = errors.New("license file not found")
)

// Request represents the input from go-pre-commit
type Request struct {
	Command string            `json:"command"`
	Files   []string          `json:"files"`
	Config  map[string]string `json:"config,omitempty"`
}

// Response represents the output to go-pre-commit
type Response struct {
	Success    bool     `json:"success"`
	Error      string   `json:"error,omitempty"`
	Suggestion string   `json:"suggestion,omitempty"`
	Modified   []string `json:"modified,omitempty"`
	Output     string   `json:"output,omitempty"`
}

func main() {
	// Read request from stdin
	var req Request
	decoder := json.NewDecoder(os.Stdin)
	if err := decoder.Decode(&req); err != nil {
		sendResponse(false, "Failed to parse input: "+err.Error(), "Ensure valid JSON is sent to plugin", nil, "")
		os.Exit(1)
	}

	// Handle command
	switch req.Command {
	case "check":
		checkLicenseHeaders(req.Files)
	default:
		sendResponse(false, "Unknown command: "+req.Command, "Supported commands: check", nil, "")
		os.Exit(1)
	}
}

func checkLicenseHeaders(files []string) {
	// Get configuration
	licenseFile := os.Getenv("LICENSE_FILE")
	if licenseFile == "" {
		licenseFile = "LICENSE"
	}

	licenseHeader := os.Getenv("LICENSE_HEADER")
	skipGenerated := os.Getenv("SKIP_GENERATED") != "false"

	// Read license header if not provided
	if licenseHeader == "" {
		header, err := readLicenseHeader(licenseFile)
		if err != nil {
			sendResponse(false, "Failed to read license: "+err.Error(),
				"Create a LICENSE file or set LICENSE_HEADER environment variable", nil, "")
			os.Exit(1)
		}
		licenseHeader = header
	}

	// Check each file
	var missingHeaders []string
	var outputs []string

	for _, file := range files {
		if skipGenerated && isGeneratedFile(file) {
			continue
		}

		hasHeader, err := fileHasLicenseHeader(file, licenseHeader)
		if err != nil {
			outputs = append(outputs, fmt.Sprintf("%s: Error: %v", file, err))
			continue
		}

		if !hasHeader {
			missingHeaders = append(missingHeaders, file)
			outputs = append(outputs, fmt.Sprintf("%s: Missing license header", file))
		}
	}

	// Generate response
	if len(missingHeaders) > 0 {
		sendResponse(false,
			fmt.Sprintf("%d file(s) missing license headers", len(missingHeaders)),
			"Add license headers to the beginning of source files",
			missingHeaders,
			strings.Join(outputs, "\n"))
		os.Exit(1)
	}

	sendResponse(true, "", "", nil,
		fmt.Sprintf("All %d file(s) have proper license headers", len(files)))
}

func readLicenseHeader(licenseFile string) (string, error) {
	// Try to read from repository root
	paths := []string{
		licenseFile,
		filepath.Join("..", licenseFile),
		filepath.Join("../..", licenseFile),
	}

	for _, path := range paths {
		content, err := os.ReadFile(path) // #nosec G304 - Reading license file from known paths
		if err == nil {
			// Extract first paragraph as header
			lines := strings.Split(string(content), "\n")
			var header []string
			for _, line := range lines {
				if strings.TrimSpace(line) == "" && len(header) > 0 {
					break
				}
				if strings.TrimSpace(line) != "" {
					header = append(header, line)
				}
			}
			if len(header) > 0 {
				return strings.Join(header, "\n"), nil
			}
		}
	}

	return "", ErrLicenseFileNotFound
}

func isGeneratedFile(filepath string) bool {
	// Check if file contains generated code marker
	file, err := os.Open(filepath) // #nosec G304 - Opening files specified by pre-commit for checking
	if err != nil {
		return false
	}
	defer func() {
		_ = file.Close()
	}()

	scanner := bufio.NewScanner(file)
	lineCount := 0
	for scanner.Scan() && lineCount < 10 {
		line := scanner.Text()
		if strings.Contains(line, "Code generated") ||
			strings.Contains(line, "DO NOT EDIT") ||
			strings.Contains(line, "Autogenerated") {
			return true
		}
		lineCount++
	}

	return false
}

func fileHasLicenseHeader(filepath, expectedHeader string) (bool, error) {
	file, err := os.Open(filepath) // #nosec G304 - Opening files specified by pre-commit for checking
	if err != nil {
		return false, err
	}
	defer func() {
		_ = file.Close()
	}()

	// Read first part of file
	buffer := make([]byte, len(expectedHeader)*2)
	n, err := file.Read(buffer)
	if err != nil && !errors.Is(err, io.EOF) {
		return false, err
	}

	content := string(buffer[:n])

	// Check if header is present (allowing for comment markers)
	headerLines := strings.Split(expectedHeader, "\n")
	for _, line := range headerLines {
		if line != "" && !strings.Contains(content, strings.TrimSpace(line)) {
			return false, nil
		}
	}

	return true, nil
}

func sendResponse(success bool, errorMsg, suggestion string, modified []string, output string) {
	resp := Response{
		Success:    success,
		Error:      errorMsg,
		Suggestion: suggestion,
		Modified:   modified,
		Output:     output,
	}

	encoder := json.NewEncoder(os.Stdout)
	if err := encoder.Encode(resp); err != nil {
		// If we can't write the response, there's nothing we can do
		// The plugin runner will detect the failure
		_ = err
	}
}
