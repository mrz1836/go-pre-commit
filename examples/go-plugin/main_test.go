package main

import (
	"bytes"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestReadLicenseHeader(t *testing.T) {
	tests := map[string]struct {
		setup          func(t *testing.T) (string, func())
		expectedHeader string
		expectedErr    error
	}{
		"reads license from current directory": {
			setup: func(t *testing.T) (string, func()) {
				tmpDir := t.TempDir()
				licensePath := filepath.Join(tmpDir, "LICENSE")
				require.NoError(t, os.WriteFile(licensePath, []byte("MIT License\nCopyright (c) 2024\n\nPermission is hereby granted..."), 0o600))

				oldWd, err := os.Getwd()
				require.NoError(t, err)
				require.NoError(t, os.Chdir(tmpDir))

				return licensePath, func() {
					require.NoError(t, os.Chdir(oldWd))
				}
			},
			expectedHeader: "MIT License\nCopyright (c) 2024",
			expectedErr:    nil,
		},
		"reads license from parent directory": {
			setup: func(t *testing.T) (string, func()) {
				tmpDir := t.TempDir()
				subDir := filepath.Join(tmpDir, "subdir")
				require.NoError(t, os.Mkdir(subDir, 0o750))

				licensePath := filepath.Join(tmpDir, "LICENSE")
				require.NoError(t, os.WriteFile(licensePath, []byte("Apache License 2.0"), 0o600))

				oldWd, err := os.Getwd()
				require.NoError(t, err)
				require.NoError(t, os.Chdir(subDir))

				return licensePath, func() {
					require.NoError(t, os.Chdir(oldWd))
				}
			},
			expectedHeader: "Apache License 2.0",
			expectedErr:    nil,
		},
		"returns error when license file not found": {
			setup: func(t *testing.T) (string, func()) {
				tmpDir := t.TempDir()
				oldWd, err := os.Getwd()
				require.NoError(t, err)
				require.NoError(t, os.Chdir(tmpDir))

				return "", func() {
					require.NoError(t, os.Chdir(oldWd))
				}
			},
			expectedHeader: "",
			expectedErr:    ErrLicenseFileNotFound,
		},
		"extracts first paragraph only": {
			setup: func(t *testing.T) (string, func()) {
				tmpDir := t.TempDir()
				licensePath := filepath.Join(tmpDir, "LICENSE")
				content := "First line\nSecond line\n\nThird line after blank"
				require.NoError(t, os.WriteFile(licensePath, []byte(content), 0o600))

				oldWd, err := os.Getwd()
				require.NoError(t, err)
				require.NoError(t, os.Chdir(tmpDir))

				return licensePath, func() {
					require.NoError(t, os.Chdir(oldWd))
				}
			},
			expectedHeader: "First line\nSecond line",
			expectedErr:    nil,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			_, cleanup := tc.setup(t)
			defer cleanup()

			header, err := readLicenseHeader("LICENSE")

			if tc.expectedErr != nil {
				require.ErrorIs(t, err, tc.expectedErr)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tc.expectedHeader, header)
			}
		})
	}
}

func TestIsGeneratedFile(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		content  string
		expected bool
	}{
		"detects Code generated marker": {
			content:  "// Code generated by tool. DO NOT EDIT.\npackage main\n",
			expected: true,
		},
		"detects DO NOT EDIT marker": {
			content:  "// DO NOT EDIT - autogenerated\npackage main\n",
			expected: true,
		},
		"detects Autogenerated marker": {
			content:  "// Autogenerated by script\npackage main\n",
			expected: true,
		},
		"non-generated file": {
			content:  "// Package main is awesome\npackage main\n",
			expected: false,
		},
		"marker after first 10 lines is ignored": {
			content:  strings.Repeat("// Line\n", 11) + "// Code generated\n",
			expected: false,
		},
		"handles file read error gracefully": {
			content:  "",
			expected: false,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			var testFile string
			if tc.content != "" {
				tmpFile, err := os.CreateTemp("", "test-*.go")
				require.NoError(t, err)
				defer func() { _ = os.Remove(tmpFile.Name()) }()

				_, err = tmpFile.WriteString(tc.content)
				require.NoError(t, err)
				require.NoError(t, tmpFile.Close())
				testFile = tmpFile.Name()
			} else {
				testFile = "/nonexistent/file.go"
			}

			result := isGeneratedFile(testFile)
			assert.Equal(t, tc.expected, result)
		})
	}
}

func TestFileHasLicenseHeader(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		fileContent    string
		expectedHeader string
		expected       bool
		expectError    bool
	}{
		"file has exact header": {
			fileContent:    "// MIT License\n// Copyright 2024\npackage main\n",
			expectedHeader: "MIT License\nCopyright 2024",
			expected:       true,
			expectError:    false,
		},
		"file has header with comments": {
			fileContent:    "// Copyright 2024 Authors\n// Licensed under MIT\npackage main\n",
			expectedHeader: "Copyright 2024 Authors\nLicensed under MIT",
			expected:       true,
			expectError:    false,
		},
		"file missing header": {
			fileContent:    "package main\nimport \"fmt\"\n",
			expectedHeader: "MIT License",
			expected:       false,
			expectError:    false,
		},
		"file has partial header": {
			fileContent:    "// MIT License\npackage main\n",
			expectedHeader: "MIT License\nCopyright 2024",
			expected:       false,
			expectError:    false,
		},
		"nonexistent file returns error": {
			fileContent:    "",
			expectedHeader: "MIT",
			expected:       false,
			expectError:    true,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			var testFile string
			if tc.fileContent != "" {
				tmpFile, err := os.CreateTemp("", "test-*.go")
				require.NoError(t, err)
				defer func() { _ = os.Remove(tmpFile.Name()) }()

				_, err = tmpFile.WriteString(tc.fileContent)
				require.NoError(t, err)
				require.NoError(t, tmpFile.Close())
				testFile = tmpFile.Name()
			} else {
				testFile = "/nonexistent/file.go"
			}

			result, err := fileHasLicenseHeader(testFile, tc.expectedHeader)

			if tc.expectError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tc.expected, result)
			}
		})
	}
}

func TestSendResponse(t *testing.T) {
	tests := map[string]struct {
		success    bool
		errorMsg   string
		suggestion string
		modified   []string
		output     string
	}{
		"success response": {
			success:    true,
			errorMsg:   "",
			suggestion: "",
			modified:   nil,
			output:     "All files passed",
		},
		"error response with suggestion": {
			success:    false,
			errorMsg:   "Missing headers",
			suggestion: "Add license headers",
			modified:   []string{"file1.go", "file2.go"},
			output:     "2 files failed",
		},
		"response with empty fields": {
			success:    true,
			errorMsg:   "",
			suggestion: "",
			modified:   nil,
			output:     "",
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			// Capture stdout
			oldStdout := os.Stdout
			r, w, err := os.Pipe()
			require.NoError(t, err)
			os.Stdout = w

			sendResponse(tc.success, tc.errorMsg, tc.suggestion, tc.modified, tc.output)

			// Restore stdout
			require.NoError(t, w.Close())
			os.Stdout = oldStdout

			// Read captured output
			var buf bytes.Buffer
			_, err = buf.ReadFrom(r)
			require.NoError(t, err)

			// Parse JSON response
			var resp Response
			err = json.Unmarshal(buf.Bytes(), &resp)
			require.NoError(t, err)

			assert.Equal(t, tc.success, resp.Success)
			assert.Equal(t, tc.errorMsg, resp.Error)
			assert.Equal(t, tc.suggestion, resp.Suggestion)
			assert.Equal(t, tc.modified, resp.Modified)
			assert.Equal(t, tc.output, resp.Output)
		})
	}
}

func TestCheckLicenseHeaders(t *testing.T) {
	tests := map[string]struct {
		setupEnv       func(t *testing.T) func()
		setupFiles     func(t *testing.T) []string
		expectedExit   bool
		expectedOutput string
	}{
		"all files have headers": {
			setupEnv: func(t *testing.T) func() {
				oldEnv := os.Getenv("LICENSE_HEADER")
				require.NoError(t, os.Setenv("LICENSE_HEADER", "MIT License"))
				return func() {
					require.NoError(t, os.Setenv("LICENSE_HEADER", oldEnv))
				}
			},
			setupFiles: func(t *testing.T) []string {
				return []string{}
			},
			expectedExit:   false,
			expectedOutput: "All 0 file(s) have proper license headers",
		},
		"files with proper headers pass": {
			setupEnv: func(t *testing.T) func() {
				oldEnv := os.Getenv("LICENSE_HEADER")
				require.NoError(t, os.Setenv("LICENSE_HEADER", "Copyright 2024"))
				return func() {
					require.NoError(t, os.Setenv("LICENSE_HEADER", oldEnv))
				}
			},
			setupFiles: func(t *testing.T) []string {
				tmpFile, err := os.CreateTemp("", "test-*.go")
				require.NoError(t, err)
				_, err = tmpFile.WriteString("// Copyright 2024\npackage main\n")
				require.NoError(t, err)
				require.NoError(t, tmpFile.Close())
				return []string{tmpFile.Name()}
			},
			expectedExit:   false,
			expectedOutput: "All 1 file(s) have proper license headers",
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			cleanup := tc.setupEnv(t)
			defer cleanup()

			files := tc.setupFiles(t)
			defer func() {
				for _, f := range files {
					_ = os.Remove(f)
				}
			}()

			// Capture stdout
			oldStdout := os.Stdout
			r, w, err := os.Pipe()
			require.NoError(t, err)
			os.Stdout = w

			if !tc.expectedExit {
				checkLicenseHeaders(files)

				// Restore stdout
				require.NoError(t, w.Close())
				os.Stdout = oldStdout

				// Read captured output
				var buf bytes.Buffer
				_, err = buf.ReadFrom(r)
				require.NoError(t, err)

				assert.Contains(t, buf.String(), tc.expectedOutput)
			}
		})
	}
}

func TestReadLicenseHeader_CustomFile(t *testing.T) {
	tmpDir := t.TempDir()
	customPath := filepath.Join(tmpDir, "CUSTOM_LICENSE")
	require.NoError(t, os.WriteFile(customPath, []byte("Custom License Header"), 0600))

	oldWd, err := os.Getwd()
	require.NoError(t, err)
	defer func() { _ = os.Chdir(oldWd) }()
	require.NoError(t, os.Chdir(tmpDir))

	header, err := readLicenseHeader("CUSTOM_LICENSE")
	require.NoError(t, err)
	assert.Equal(t, "Custom License Header", header)
}

func TestCheckLicenseHeaders_LicenseFileLoading(t *testing.T) {
	tests := map[string]struct {
		setupEnv   func(t *testing.T) (func(), string)
		setupFiles func(t *testing.T) []string
	}{
		"reads from LICENSE file when no env var": {
			setupEnv: func(t *testing.T) (func(), string) {
				tmpDir := t.TempDir()
				licensePath := filepath.Join(tmpDir, "LICENSE")
				require.NoError(t, os.WriteFile(licensePath, []byte("MIT License\nCopyright 2024"), 0600))

				oldWd, err := os.Getwd()
				require.NoError(t, err)
				require.NoError(t, os.Chdir(tmpDir))

				oldEnv := os.Getenv("LICENSE_HEADER")
				oldFile := os.Getenv("LICENSE_FILE")
				require.NoError(t, os.Setenv("LICENSE_HEADER", ""))
				require.NoError(t, os.Setenv("LICENSE_FILE", ""))

				return func() {
					require.NoError(t, os.Chdir(oldWd))
					require.NoError(t, os.Setenv("LICENSE_HEADER", oldEnv))
					require.NoError(t, os.Setenv("LICENSE_FILE", oldFile))
				}, tmpDir
			},
			setupFiles: func(t *testing.T) []string {
				tmpFile, err := os.CreateTemp("", "test-*.go")
				require.NoError(t, err)
				_, err = tmpFile.WriteString("// MIT License\n// Copyright 2024\npackage main\n")
				require.NoError(t, err)
				require.NoError(t, tmpFile.Close())
				return []string{tmpFile.Name()}
			},
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			cleanup, _ := tc.setupEnv(t)
			defer cleanup()

			files := tc.setupFiles(t)
			defer func() {
				for _, f := range files {
					_ = os.Remove(f)
				}
			}()

			oldStdout := os.Stdout
			r, w, err := os.Pipe()
			require.NoError(t, err)
			os.Stdout = w

			checkLicenseHeaders(files)

			require.NoError(t, w.Close())
			os.Stdout = oldStdout

			var buf bytes.Buffer
			_, err = buf.ReadFrom(r)
			require.NoError(t, err)

			assert.Contains(t, buf.String(), "file(s) have proper license headers")
		})
	}
}

func TestRequestResponseStructs(t *testing.T) {
	t.Parallel()

	t.Run("Request JSON marshaling", func(t *testing.T) {
		t.Parallel()

		req := Request{
			Command: "check",
			Files:   []string{"file1.go", "file2.go"},
			Config:  map[string]string{"key": "value"},
		}

		data, err := json.Marshal(req)
		require.NoError(t, err)

		var decoded Request
		err = json.Unmarshal(data, &decoded)
		require.NoError(t, err)

		assert.Equal(t, req.Command, decoded.Command)
		assert.Equal(t, req.Files, decoded.Files)
		assert.Equal(t, req.Config, decoded.Config)
	})

	t.Run("Response JSON marshaling", func(t *testing.T) {
		t.Parallel()

		resp := Response{
			Success:    false,
			Error:      "test error",
			Suggestion: "test suggestion",
			Modified:   []string{"file.go"},
			Output:     "test output",
		}

		data, err := json.Marshal(resp)
		require.NoError(t, err)

		var decoded Response
		err = json.Unmarshal(data, &decoded)
		require.NoError(t, err)

		assert.Equal(t, resp.Success, decoded.Success)
		assert.Equal(t, resp.Error, decoded.Error)
		assert.Equal(t, resp.Suggestion, decoded.Suggestion)
		assert.Equal(t, resp.Modified, decoded.Modified)
		assert.Equal(t, resp.Output, decoded.Output)
	})
}
