
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>plugins: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/mrz1836/go-pre-commit/internal/plugins/plugin.go (82.4%)</option>

				<option value="file1">github.com/mrz1836/go-pre-commit/internal/plugins/registry.go (94.1%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package plugins provides a plugin system for custom pre-commit hooks
package plugins

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        prerrors "github.com/mrz1836/go-pre-commit/internal/errors"
)

// Define plugin errors
var (
        ErrManifestNil     = errors.New("manifest cannot be nil")
        ErrPluginNameEmpty = errors.New("plugin name is required")
        ErrExecutableEmpty = errors.New("plugin executable is required")
)

// PluginManifest defines the structure of a plugin configuration file
type PluginManifest struct {
        // Basic metadata
        Name        string `json:"name" yaml:"name"`
        Version     string `json:"version" yaml:"version"`
        Description string `json:"description" yaml:"description"`
        Author      string `json:"author,omitempty" yaml:"author,omitempty"`
        License     string `json:"license,omitempty" yaml:"license,omitempty"`
        Homepage    string `json:"homepage,omitempty" yaml:"homepage,omitempty"`

        // Execution configuration
        Executable    string            `json:"executable" yaml:"executable"`
        Args          []string          `json:"args,omitempty" yaml:"args,omitempty"`
        FilePatterns  []string          `json:"file_patterns" yaml:"file_patterns"`
        Timeout       string            `json:"timeout,omitempty" yaml:"timeout,omitempty"`
        Category      string            `json:"category,omitempty" yaml:"category,omitempty"`
        RequiresFiles bool              `json:"requires_files,omitempty" yaml:"requires_files,omitempty"`
        Environment   map[string]string `json:"environment,omitempty" yaml:"environment,omitempty"`

        // Advanced configuration
        Dependencies []string `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`
        MinVersion   string   `json:"min_go_pre_commit_version,omitempty" yaml:"min_go_pre_commit_version,omitempty"`
        MaxVersion   string   `json:"max_go_pre_commit_version,omitempty" yaml:"max_go_pre_commit_version,omitempty"`

        // Security settings
        ReadOnly      bool     `json:"read_only,omitempty" yaml:"read_only,omitempty"`
        AllowedPaths  []string `json:"allowed_paths,omitempty" yaml:"allowed_paths,omitempty"`
        MaxMemoryMB   int      `json:"max_memory_mb,omitempty" yaml:"max_memory_mb,omitempty"`
        MaxCPUPercent int      `json:"max_cpu_percent,omitempty" yaml:"max_cpu_percent,omitempty"`
}

// Plugin represents a custom check implemented as an external executable
type Plugin struct {
        manifest  *PluginManifest
        directory string
        timeout   time.Duration
}

// NewPlugin creates a new plugin from a manifest and directory
func NewPlugin(manifest *PluginManifest, directory string) (*Plugin, error) <span class="cov8" title="1">{
        if manifest == nil </span><span class="cov8" title="1">{
                return nil, ErrManifestNil
        }</span>

        <span class="cov8" title="1">if manifest.Name == "" </span><span class="cov8" title="1">{
                return nil, ErrPluginNameEmpty
        }</span>

        <span class="cov8" title="1">if manifest.Executable == "" </span><span class="cov8" title="1">{
                return nil, ErrExecutableEmpty
        }</span>

        // Parse timeout
        <span class="cov8" title="1">timeout := 30 * time.Second // default
        if manifest.Timeout != "" </span><span class="cov8" title="1">{
                parsedTimeout, err := time.ParseDuration(manifest.Timeout)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid timeout format: %w", err)
                }</span>
                <span class="cov8" title="1">timeout = parsedTimeout</span>
        }

        <span class="cov8" title="1">return &amp;Plugin{
                manifest:  manifest,
                directory: directory,
                timeout:   timeout,
        }, nil</span>
}

// Name returns the name of the plugin
func (p *Plugin) Name() string <span class="cov8" title="1">{
        return p.manifest.Name
}</span>

// Description returns a brief description of the plugin
func (p *Plugin) Description() string <span class="cov8" title="1">{
        return p.manifest.Description
}</span>

// Metadata returns comprehensive metadata about the plugin
func (p *Plugin) Metadata() interface{} <span class="cov8" title="1">{
        return PluginMetadata{
                Name:              p.manifest.Name,
                Description:       p.manifest.Description,
                FilePatterns:      p.manifest.FilePatterns,
                EstimatedDuration: p.timeout,
                Dependencies:      p.manifest.Dependencies,
                DefaultTimeout:    p.timeout,
                Category:          p.manifest.Category,
                RequiresFiles:     p.manifest.RequiresFiles,
                Version:           p.manifest.Version,
                Author:            p.manifest.Author,
        }
}</span>

// Run executes the plugin on the given files
func (p *Plugin) Run(ctx context.Context, files []string) error <span class="cov8" title="1">{
        // Add timeout to context
        ctx, cancel := context.WithTimeout(ctx, p.timeout)
        defer cancel()

        // Prepare executable path
        execPath := p.manifest.Executable
        if !filepath.IsAbs(execPath) </span><span class="cov8" title="1">{
                execPath = filepath.Join(p.directory, execPath)
        }</span>

        // Check if executable exists
        <span class="cov8" title="1">if _, err := os.Stat(execPath); err != nil </span><span class="cov8" title="1">{
                return prerrors.NewToolNotFoundError(
                        p.manifest.Name,
                        fmt.Sprintf("Plugin executable not found: %s", execPath),
                )
        }</span>

        // Build command arguments
        <span class="cov8" title="1">args := append([]string{}, p.manifest.Args...)

        // Create command
        cmd := exec.CommandContext(ctx, execPath, args...) //nolint:gosec // Plugin execution
        cmd.Dir = p.directory

        // Set environment variables
        cmd.Env = os.Environ()
        for key, value := range p.manifest.Environment </span><span class="cov0" title="0">{
                // Expand environment variables in value
                expandedValue := os.ExpandEnv(value)
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, expandedValue))
        }</span>

        // Create plugin request
        <span class="cov8" title="1">request := PluginRequest{
                Files:   files,
                Command: "check",
                Config:  p.manifest.Environment,
        }

        // Marshal request to JSON
        requestJSON, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal plugin request: %w", err)
        }</span>

        // Set up stdin with the request
        <span class="cov8" title="1">cmd.Stdin = bytes.NewReader(requestJSON)

        // Capture output
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Execute the plugin
        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                // Check if it's a context timeout
                if errors.Is(ctx.Err(), context.DeadlineExceeded) </span><span class="cov8" title="1">{
                        return prerrors.NewToolExecutionError(
                                p.manifest.Name,
                                stderr.String(),
                                fmt.Sprintf("Plugin timed out after %v", p.timeout),
                        )
                }</span>

                // Try to parse plugin response for structured error
                <span class="cov0" title="0">var response PluginResponse
                if jsonErr := json.Unmarshal(stdout.Bytes(), &amp;response); jsonErr == nil &amp;&amp; response.Error != "" </span><span class="cov0" title="0">{
                        return prerrors.NewToolExecutionError(
                                p.manifest.Name,
                                response.Error,
                                response.Suggestion,
                        )
                }</span>

                // Generic error
                <span class="cov0" title="0">return prerrors.NewToolExecutionError(
                        p.manifest.Name,
                        stderr.String(),
                        fmt.Sprintf("Plugin failed with exit code: %v", err),
                )</span>
        }

        // Parse successful response
        <span class="cov8" title="1">var response PluginResponse
        if err := json.Unmarshal(stdout.Bytes(), &amp;response); err != nil </span><span class="cov0" title="0">{
                // If the plugin doesn't use JSON protocol, treat empty output as success
                if len(stdout.Bytes()) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // Non-JSON output is treated as an error message
                <span class="cov0" title="0">if strings.TrimSpace(stdout.String()) != "" </span><span class="cov0" title="0">{
                        return prerrors.NewToolExecutionError(
                                p.manifest.Name,
                                stdout.String(),
                                "Plugin output was not in expected JSON format",
                        )
                }</span>
        }

        // Check if plugin reported an error
        <span class="cov8" title="1">if !response.Success </span><span class="cov0" title="0">{
                return prerrors.NewToolExecutionError(
                        p.manifest.Name,
                        response.Error,
                        response.Suggestion,
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// FilterFiles filters the list of files to only those this plugin should process
func (p *Plugin) FilterFiles(files []string) []string <span class="cov8" title="1">{
        if len(p.manifest.FilePatterns) == 0 </span><span class="cov8" title="1">{
                return files // No filtering if no patterns specified
        }</span>

        <span class="cov8" title="1">var filtered []string
        for _, file := range files </span><span class="cov8" title="1">{
                for _, pattern := range p.manifest.FilePatterns </span><span class="cov8" title="1">{
                        // Simple pattern matching (could be enhanced with glob support)
                        if strings.HasPrefix(pattern, "*.") </span><span class="cov8" title="1">{
                                // Extension matching
                                ext := pattern[1:] // Remove the *
                                if strings.HasSuffix(file, ext) </span><span class="cov8" title="1">{
                                        filtered = append(filtered, file)
                                        break</span>
                                }
                        } else<span class="cov8" title="1"> if matched, _ := filepath.Match(pattern, file); matched </span><span class="cov8" title="1">{
                                // Glob pattern matching
                                filtered = append(filtered, file)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return filtered</span>
}

// PluginMetadata contains metadata about a plugin
type PluginMetadata struct {
        Name              string
        Description       string
        FilePatterns      []string
        EstimatedDuration time.Duration
        Dependencies      []string
        DefaultTimeout    time.Duration
        Category          string
        RequiresFiles     bool
        Version           string
        Author            string
}

// PluginRequest is the JSON structure sent to plugins via stdin
type PluginRequest struct {
        Command string            `json:"command"`
        Files   []string          `json:"files"`
        Config  map[string]string `json:"config,omitempty"`
}

// PluginResponse is the JSON structure expected from plugins via stdout
type PluginResponse struct {
        Success    bool     `json:"success"`
        Error      string   `json:"error,omitempty"`
        Suggestion string   `json:"suggestion,omitempty"`
        Modified   []string `json:"modified,omitempty"`
        Output     string   `json:"output,omitempty"`
}
</pre>

		<pre class="file" id="file1" style="display: none">package plugins

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "gopkg.in/yaml.v3"
)

// Define registry errors
var (
        ErrPluginAlreadyRegistered = errors.New("plugin already registered")
        ErrPluginNil               = errors.New("plugin cannot be nil")
        ErrNoManifestFound         = errors.New("no manifest file found (looked for plugin.yaml, plugin.yml, plugin.json)")
        ErrPluginsLoadFailed       = errors.New("failed to load some plugins")
)

// Registry manages plugin discovery and loading
type Registry struct {
        plugins   map[string]*Plugin
        directory string
        mu        sync.RWMutex
}

// NewRegistry creates a new plugin registry
func NewRegistry(directory string) *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                plugins:   make(map[string]*Plugin),
                directory: directory,
        }
}</span>

// LoadPlugins discovers and loads all plugins from the registry directory
func (r *Registry) LoadPlugins() error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Check if plugin directory exists
        if _, err := os.Stat(r.directory); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Plugin directory doesn't exist, which is fine (no plugins)
                return nil
        }</span>

        // Walk through the plugin directory
        <span class="cov8" title="1">entries, err := os.ReadDir(r.directory)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read plugin directory: %w", err)
        }</span>

        <span class="cov8" title="1">var loadErrors []string

        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">pluginDir := filepath.Join(r.directory, entry.Name())

                // Try to load plugin from this directory
                if err := r.loadPlugin(pluginDir); err != nil </span><span class="cov8" title="1">{
                        loadErrors = append(loadErrors, fmt.Sprintf("%s: %v", entry.Name(), err))
                }</span>
        }

        <span class="cov8" title="1">if len(loadErrors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w:\n%s", ErrPluginsLoadFailed, strings.Join(loadErrors, "\n"))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadPlugin loads a single plugin from a directory
func (r *Registry) loadPlugin(directory string) error <span class="cov8" title="1">{
        // Look for manifest file (plugin.yaml or plugin.json)
        manifest, err := r.loadManifest(directory)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load manifest: %w", err)
        }</span>

        // Create plugin instance
        <span class="cov8" title="1">plugin, err := NewPlugin(manifest, directory)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create plugin: %w", err)
        }</span>

        // Check for duplicate names
        <span class="cov8" title="1">if _, exists := r.plugins[plugin.Name()]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrPluginAlreadyRegistered, plugin.Name())
        }</span>

        // Register the plugin
        <span class="cov8" title="1">r.plugins[plugin.Name()] = plugin

        return nil</span>
}

// loadManifest loads a plugin manifest from a directory
func (r *Registry) loadManifest(directory string) (*PluginManifest, error) <span class="cov8" title="1">{
        // Clean the directory path to prevent path traversal
        directory = filepath.Clean(directory)

        // Try YAML first
        yamlPath := filepath.Join(directory, "plugin.yaml")
        // #nosec G304 - Path is safely constructed with known filename
        if data, err := os.ReadFile(yamlPath); err == nil </span><span class="cov8" title="1">{
                var manifest PluginManifest
                if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse plugin.yaml: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;manifest, nil</span>
        }

        // Try alternative YAML extension
        <span class="cov8" title="1">ymlPath := filepath.Join(directory, "plugin.yml")
        // #nosec G304 - Path is safely constructed with known filename
        if data, err := os.ReadFile(ymlPath); err == nil </span><span class="cov8" title="1">{
                var manifest PluginManifest
                if err := yaml.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse plugin.yml: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;manifest, nil</span>
        }

        // Try JSON
        <span class="cov8" title="1">jsonPath := filepath.Join(directory, "plugin.json")
        // #nosec G304 - Path is safely constructed with known filename
        if data, err := os.ReadFile(jsonPath); err == nil </span><span class="cov8" title="1">{
                var manifest PluginManifest
                if err := json.Unmarshal(data, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse plugin.json: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;manifest, nil</span>
        }

        <span class="cov8" title="1">return nil, ErrNoManifestFound</span>
}

// Get returns a plugin by name
func (r *Registry) Get(name string) (*Plugin, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        plugin, ok := r.plugins[name]
        return plugin, ok
}</span>

// GetAll returns all loaded plugins
func (r *Registry) GetAll() []*Plugin <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        plugins := make([]*Plugin, 0, len(r.plugins))
        for _, plugin := range r.plugins </span><span class="cov8" title="1">{
                plugins = append(plugins, plugin)
        }</span>
        <span class="cov8" title="1">return plugins</span>
}

// Names returns the names of all loaded plugins
func (r *Registry) Names() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        names := make([]string, 0, len(r.plugins))
        for name := range r.plugins </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// AddPlugin manually adds a plugin to the registry
func (r *Registry) AddPlugin(plugin *Plugin) error <span class="cov8" title="1">{
        if plugin == nil </span><span class="cov8" title="1">{
                return ErrPluginNil
        }</span>

        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.plugins[plugin.Name()]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrPluginAlreadyRegistered, plugin.Name())
        }</span>

        <span class="cov8" title="1">r.plugins[plugin.Name()] = plugin
        return nil</span>
}

// RemovePlugin removes a plugin from the registry
func (r *Registry) RemovePlugin(name string) bool <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.plugins[name]; exists </span><span class="cov8" title="1">{
                delete(r.plugins, name)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// ValidateManifest validates a plugin manifest without loading it
func ValidateManifest(manifest *PluginManifest) []string <span class="cov8" title="1">{
        var errors []string

        if manifest.Name == "" </span><span class="cov8" title="1">{
                errors = append(errors, "plugin name is required")
        }</span>

        <span class="cov8" title="1">if manifest.Version == "" </span><span class="cov8" title="1">{
                errors = append(errors, "plugin version is required")
        }</span>

        <span class="cov8" title="1">if manifest.Description == "" </span><span class="cov8" title="1">{
                errors = append(errors, "plugin description is required")
        }</span>

        <span class="cov8" title="1">if manifest.Executable == "" </span><span class="cov8" title="1">{
                errors = append(errors, "plugin executable is required")
        }</span>

        <span class="cov8" title="1">if len(manifest.FilePatterns) == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "at least one file pattern is required")
        }</span>

        // Validate timeout format if specified
        <span class="cov8" title="1">if manifest.Timeout != "" </span><span class="cov8" title="1">{
                if _, err := time.ParseDuration(manifest.Timeout); err != nil </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("invalid timeout format: %v", err))
                }</span>
        }

        // Validate category if specified
        <span class="cov8" title="1">validCategories := []string{"formatting", "linting", "security", "testing", "documentation", "custom"}
        if manifest.Category != "" </span><span class="cov8" title="1">{
                valid := false
                for _, cat := range validCategories </span><span class="cov8" title="1">{
                        if manifest.Category == cat </span><span class="cov8" title="1">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("invalid category '%s', must be one of: %v", manifest.Category, validCategories))
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
