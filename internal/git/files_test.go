package git

import (
	"bytes"
	"context"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/mrz1836/go-pre-commit/internal/config"
)

type FileClassifierTestSuite struct {
	suite.Suite

	tempDir    string
	classifier *FileClassifier
}

func TestFileClassifierSuite(t *testing.T) {
	suite.Run(t, new(FileClassifierTestSuite))
}

func (ts *FileClassifierTestSuite) SetupTest() {
	tempDir, err := os.MkdirTemp("", "file-classifier-test-*")
	ts.Require().NoError(err)
	ts.tempDir = tempDir

	cfg := &config.Config{
		MaxFileSize: 1024 * 1024, // 1MB
	}
	cfg.Git.ExcludePatterns = []string{"*.excluded", "excluded/"}
	ts.classifier = NewFileClassifier(cfg)
}

func (ts *FileClassifierTestSuite) TearDownTest() {
	if ts.tempDir != "" {
		err := os.RemoveAll(ts.tempDir)
		ts.Require().NoError(err)
	}
}

func (ts *FileClassifierTestSuite) TestNewFileClassifier() {
	cfg := &config.Config{}
	fc := NewFileClassifier(cfg)
	ts.Require().NotNil(fc)
	ts.Require().Equal(cfg, fc.config)
}

func (ts *FileClassifierTestSuite) TestClassifyFilesBasic() {
	// Create test files
	goFile := ts.createFile("test.go", "package main\n\nfunc main() {}\n")
	txtFile := ts.createFile("readme.txt", "Hello World")
	binFile := ts.createBinaryFile("binary.bin", 100)

	files := []string{goFile, txtFile, binFile}

	ctx := context.Background()
	infos, err := ts.classifier.ClassifyFiles(ctx, files)
	ts.Require().NoError(err)
	ts.Require().Len(infos, 3)

	// Check Go file
	ts.Require().Equal(goFile, infos[0].Path)
	ts.Require().True(infos[0].IsGoFile)
	ts.Require().True(infos[0].IsText)
	ts.Require().False(infos[0].IsBinary)
	ts.Require().Equal("go", infos[0].Language)
	ts.Require().False(infos[0].Generated)
	ts.Require().False(infos[0].Excluded)

	// Check text file
	ts.Require().Equal(txtFile, infos[1].Path)
	ts.Require().False(infos[1].IsGoFile)
	ts.Require().True(infos[1].IsText)
	ts.Require().False(infos[1].IsBinary)
	ts.Require().Equal("text", infos[1].Language)

	// Check binary file
	ts.Require().Equal(binFile, infos[2].Path)
	ts.Require().False(infos[2].IsGoFile)
	ts.Require().False(infos[2].IsText)
	ts.Require().True(infos[2].IsBinary)
}

func (ts *FileClassifierTestSuite) TestClassifyFilesContextCancellation() {
	// Create many files to ensure context cancellation is checked
	var files []string
	for i := 0; i < 100; i++ {
		file := ts.createFile(filepath.Join("dir", "file%d.txt"), "content")
		files = append(files, file)
	}

	ctx, cancel := context.WithCancel(context.Background())
	cancel() // Cancel immediately

	infos, err := ts.classifier.ClassifyFiles(ctx, files)
	ts.Require().Error(err)
	ts.Require().Equal(context.Canceled, err)
	ts.Require().Nil(infos)
}

func (ts *FileClassifierTestSuite) TestFilterGoFiles() {
	// Create test files
	goFile1 := ts.createFile("main.go", "package main")
	goFile2 := ts.createFile("util.go", "package main")
	testFile := ts.createFile("main_test.go", "package main")
	genFile := ts.createFile("generated.pb.go", "// Code generated by protoc-gen-go. DO NOT EDIT.\npackage pb")
	txtFile := ts.createFile("readme.txt", "Hello")

	files := []string{goFile1, goFile2, testFile, genFile, txtFile}

	ctx := context.Background()

	// Test without excluding tests
	goFiles, err := ts.classifier.FilterGoFiles(ctx, files, false)
	ts.Require().NoError(err)
	ts.Require().Len(goFiles, 3) // main.go, util.go, main_test.go (generated excluded)
	ts.Require().Contains(goFiles, goFile1)
	ts.Require().Contains(goFiles, goFile2)
	ts.Require().Contains(goFiles, testFile)

	// Test excluding tests
	goFiles, err = ts.classifier.FilterGoFiles(ctx, files, true)
	ts.Require().NoError(err)
	ts.Require().Len(goFiles, 2) // main.go, util.go
	ts.Require().Contains(goFiles, goFile1)
	ts.Require().Contains(goFiles, goFile2)
}

func (ts *FileClassifierTestSuite) TestFilterTextFiles() {
	// Create test files
	txtFile := ts.createFile("readme.txt", "Hello")
	mdFile := ts.createFile("docs.md", "# Documentation")
	goFile := ts.createFile("main.go", "package main")
	binFile := ts.createBinaryFile("binary.bin", 100)
	genFile := ts.createFile("generated.txt", "// Auto-generated file. DO NOT EDIT.\nContent")

	files := []string{txtFile, mdFile, goFile, binFile, genFile}

	ctx := context.Background()
	textFiles, err := ts.classifier.FilterTextFiles(ctx, files)
	ts.Require().NoError(err)
	ts.Require().Len(textFiles, 4) // txt, md, go, generated.txt (binary excluded, but .txt files don't check for generated markers)
	ts.Require().Contains(textFiles, txtFile)
	ts.Require().Contains(textFiles, mdFile)
	ts.Require().Contains(textFiles, goFile)
	ts.Require().Contains(textFiles, genFile) // .txt files aren't checked for generated markers
}

func (ts *FileClassifierTestSuite) TestExcludeByPatterns() {
	files := []string{
		"main.go",
		"test.tmp",
		"backup.bak",
		"docs/readme.md",
		"vendor/lib.go",
		".git/config",
	}

	patterns := []string{"*.tmp", "*.bak", "vendor/", ".git/"}

	filtered := ts.classifier.ExcludeByPatterns(files, patterns)
	ts.Require().Len(filtered, 2)
	ts.Require().Contains(filtered, "main.go")
	ts.Require().Contains(filtered, "docs/readme.md")
}

func (ts *FileClassifierTestSuite) TestExcludeByPatternsEmptyPatterns() {
	files := []string{"a.go", "b.go", "c.go"}
	filtered := ts.classifier.ExcludeByPatterns(files, nil)
	ts.Require().Equal(files, filtered)
}

func (ts *FileClassifierTestSuite) TestIsGoFile() {
	tests := []struct {
		name     string
		path     string
		expected bool
	}{
		{"valid go file", "main.go", true},
		{"go file in subdirectory", "pkg/util/helper.go", true},
		{"not go file", "main.txt", false},
		{"vendor file", "vendor/github.com/lib/lib.go", false},
		{"file in vendor subdirectory", "myproject/vendor/lib.go", false},
		{"no extension", "README", false},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.isGoFile(tt.path)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestDetectLanguage() {
	tests := []struct {
		name     string
		path     string
		expected string
	}{
		{"go file", "main.go", "go"},
		{"go mod", "go.mod", "go-mod"},
		{"go sum", "go.sum", "go-sum"},
		{"python", "script.py", "python"},
		{"javascript", "app.js", "javascript"},
		{"typescript", "app.ts", "typescript"},
		{"makefile", "Makefile", "make"},
		{"dockerfile", "Dockerfile", "docker"},
		{"unknown extension", "file.xyz", "unknown"},
		{"no extension", "README", "unknown"},
		{"gitignore", ".gitignore", "gitignore"},
		{"yaml", "config.yml", "yaml"},
		{"yaml alt", "config.yaml", "yaml"},
		{"json", "data.json", "json"},
		{"shell", "script.sh", "shell"},
		{"markdown", "README.md", "markdown"},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.detectLanguage(tt.path)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestIsGeneratedFile() {
	tests := []struct {
		name     string
		path     string
		content  string
		expected bool
	}{
		{"protobuf generated", "api.pb.go", "", true},
		{"grpc gateway", "api.pb.gw.go", "", true},
		{"stringer", "types_string.go", "", true},
		{"easyjson", "model_easyjson.go", "", true},
		{"mock file", "mock_service.go", "", true},
		{"generic generated", "types_gen.go", "", true},
		{"wire generated", "wire_gen.go", "", true},
		{"normal go file", "main.go", "", false},
		{"file with generated marker", "custom.go", "// Code generated by tool. DO NOT EDIT.\npackage main", true},
		{"file with auto-generated marker", "auto.go", "// This file was automatically generated\npackage main", true},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			file := ts.createFile(tt.path, tt.content)
			result := ts.classifier.isGeneratedFile(file)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestIsExcludedPath() {
	// Test with configured excludes
	tests := []struct {
		name     string
		path     string
		expected bool
	}{
		{"vendor directory", "vendor/lib.go", true},
		{"git directory", ".git/config", true},
		{"node_modules", "node_modules/package.json", true},
		{"temp file", "test.tmp", true},
		{"log file", "app.log", true},
		{"DS_Store", ".DS_Store", true},
		{"backup file", "main.go.bak", true},
		{"coverage file", "coverage.out", true},
		{"configured exclude", "test.excluded", true},
		{"configured exclude dir", "excluded/file.go", true},
		{"normal file", "main.go", false},
		{"normal directory", "src/main.go", false},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.isExcludedPath(tt.path)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestIsTextContent() {
	tests := []struct {
		name     string
		content  []byte
		expected bool
	}{
		{"empty content", []byte{}, true},
		{"simple text", []byte("Hello, World!"), true},
		{"text with newlines", []byte("Line 1\nLine 2\nLine 3"), true},
		{"text with tabs", []byte("Column1\tColumn2\tColumn3"), true},
		{"binary with null bytes", []byte{0x00, 0x01, 0x02, 0x03}, false},
		{"binary with high control chars", []byte{0x01, 0x02, 0x03, 0x04, 0x05}, false},
		{"invalid UTF-8", []byte{0xFF, 0xFE, 0xFD}, false},
		{"mixed content mostly text", []byte("Hello\x01World"), true},
		{"mixed content mostly binary", bytes.Repeat([]byte{0x01}, 100), false},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.isTextContent(tt.content)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestMatchesPattern() {
	tests := []struct {
		name     string
		str      string
		pattern  string
		expected bool
	}{
		{"exact match", "test.go", "test.go", true},
		{"no match", "test.go", "main.go", false},
		{"wildcard suffix", "test.go", "*.go", true},
		{"wildcard prefix", "test.go", "test.*", true},
		{"wildcard middle", "test_file.go", "test*.go", true},
		{"directory pattern", "src/main.go", "src/", true},
		{"subdirectory pattern", "path/to/vendor/lib.go", "vendor/", true},
		{"contains match", "path/to/file.tmp", ".tmp", true},
		{"complex glob", "mock_service.go", "mock_*.go", true},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.matchesPattern(tt.str, tt.pattern)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestGlobMatch() {
	tests := []struct {
		name     string
		str      string
		pattern  string
		expected bool
	}{
		{"simple suffix", "test.go", "*.go", true},
		{"simple prefix", "test.go", "test.*", true},
		{"no wildcard", "test.go", "test.go", true},
		{"multiple wildcards", "test_mock_service.go", "*_mock_*.go", true},
		{"doesn't match prefix", "main.go", "test*", false},
		{"doesn't match suffix", "test.txt", "*.go", false},
	}

	for _, tt := range tests {
		ts.Run(tt.name, func() {
			result := ts.classifier.globMatch(tt.str, tt.pattern)
			ts.Require().Equal(tt.expected, result)
		})
	}
}

func (ts *FileClassifierTestSuite) TestGetFileStats() {
	// Create diverse set of files
	files := []string{
		ts.createFile("main.go", "package main"),
		ts.createFile("util.go", "package main"),
		ts.createFile("main_test.go", "package main"),
		ts.createFile("generated.pb.go", "// Code generated by protoc. DO NOT EDIT.\npackage pb"),
		ts.createFile("readme.md", "# README"),
		ts.createFile("config.json", `{"key": "value"}`),
		ts.createBinaryFile("binary.bin", 100),
		ts.createFile("test.excluded", "excluded content"),
	}

	ctx := context.Background()
	stats, err := ts.classifier.GetFileStats(ctx, files)
	ts.Require().NoError(err)

	ts.Require().Equal(8, stats["total"])
	ts.Require().Equal(6, stats["text"]) // Excluded files don't count as text
	ts.Require().Equal(1, stats["binary"])
	ts.Require().Equal(4, stats["go"])
	ts.Require().Equal(1, stats["generated"])
	ts.Require().Equal(1, stats["excluded"])
	ts.Require().Equal(1, stats["lang_markdown"])
	ts.Require().Equal(1, stats["lang_json"])
}

func (ts *FileClassifierTestSuite) TestMaxFileSizeLimit() {
	// Create a file larger than the configured max size
	largeContent := make([]byte, 2*1024*1024) // 2MB
	for i := range largeContent {
		largeContent[i] = byte('A' + (i % 26))
	}
	largeFile := ts.createFile("large.txt", string(largeContent))

	ctx := context.Background()
	infos, err := ts.classifier.ClassifyFiles(ctx, []string{largeFile})
	ts.Require().NoError(err)
	ts.Require().Len(infos, 1)
	ts.Require().True(infos[0].Excluded)
	ts.Require().Equal(int64(len(largeContent)), infos[0].Size)
}

func (ts *FileClassifierTestSuite) TestReadFileHeadErrors() {
	// Test with non-existent file
	content, err := ts.classifier.readFileHead("/non/existent/file.txt", 100)
	ts.Require().Error(err)
	ts.Require().Nil(content)
}

func (ts *FileClassifierTestSuite) TestClassifyFileErrors() {
	// Test with non-existent file
	info, err := ts.classifier.classifyFile("/non/existent/file.txt")
	ts.Require().Error(err)
	ts.Require().Contains(err.Error(), "failed to stat file")
	ts.Require().Equal("/non/existent/file.txt", info.Path)
}

// Helper methods

func (ts *FileClassifierTestSuite) createFile(name, content string) string {
	path := filepath.Join(ts.tempDir, name)
	dir := filepath.Dir(path)

	err := os.MkdirAll(dir, 0o750)
	ts.Require().NoError(err)

	err = os.WriteFile(path, []byte(content), 0o600)
	ts.Require().NoError(err)

	return path
}

func (ts *FileClassifierTestSuite) createBinaryFile(name string, size int) string {
	path := filepath.Join(ts.tempDir, name)
	content := make([]byte, size)

	// Fill with binary data including null bytes
	for i := range content {
		content[i] = byte(i % 256)
	}

	err := os.WriteFile(path, content, 0o600)
	ts.Require().NoError(err)

	return path
}
